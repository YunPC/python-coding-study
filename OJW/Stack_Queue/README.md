# 316. Remove Duplicate Letters

## 문제 풀이시 중요한 부분
* 먼저 문자에서의 사전 순서가 어떻게 되는지 알아야 한다.
* 문자의 경우 aab 가 ab 보다 먼저 온다. 각 문자의 값을 비교해준다.
* 여기서도 사전식으로 답을 출력하라고 했지만, 마냥 사전 순으로만 출력 할 수 없는 조건이 있다.
    * 중복 문자를 제거해야 하기 때문에, 만약 문자가 1개만 있는 경우에는 제거 할 수 없다. 즉, 맨 앞에 z 가 먼저 온다고 해서 사전식으로 출력하기 위해 z 를 지울 수는 없다.
* 스택은 위로 쌓인다고 배웠다. 어차피 늦게 들어온 값이 나중에 들어온다는 것은 변함이 없으니 옆으로 들어온다고 생각해도 다를 것 없다. 정말 별 내용 아니지만, 위에서 쌓는 모양을 그리는 것 보다 아이디어 내기에 직관적으로 바뀐다. (걍 내 생각일수도 있음 ㅋㅋ!ㅈㅅ;;)

## 코드 구현하기
```{.python}
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        counter, stack = collections.Count(s), []

        for char in s:
            # 일단 문자를 꺼냈기 때문에 counter 를 -1 해준다.
            count[char] -= 1

            # 만약 문자가 스택에 존재한다면, 다음 문자를 탐색하도록 한다.
            # 즉, 스택에 들어있다면 더이상 비교하지 않아도 된다라는 가정이 확실한 사실이 되도록 아래 코드를 잘 짜야한다.
            if char in stack:
                continue

            # 0. 스택에 값이 존재한다면
            # 1. 문자가 1개도 없는 경우 (중복이 없는 경우) 에는 문자를 지울 수 없다. 즉 counter 가 0 보다 커야만 지울 수 있다.
            # 2. 0, 1 을 만족하는 경우에 만약 스택의 마지막 원소가 새로 비교할 char 보다 큰 경우 (문자에서의 순서를 말한다.)
            while stack and stack[-1] > char and counter[stack[-1]] > 0:
                stack.pop()

            # 반복문의 밖에서 append 를 해주는 이유는,
            # 1. 위에서 continue 를 사용해서 원하지 않는 문자의 처리가 가능하다.
            # 2. 만약 stack 에 값이 존재하지 않는다고 해서 append 를 하지 않을 수는 없다.
            stack.append(char)

        # 리스트의 문자를 합치는 경우에는 join 을 쓰는것이 효율적이다.
        return "".join(stack)

```


